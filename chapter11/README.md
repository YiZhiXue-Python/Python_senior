# 协程和异步IO
1. 并发、并行、同步、异步、阻塞、非阻塞
    - 并发: 是指一个时间段内,有几个程序在同一个CPU上运行,但是任意时刻只有一个程序在CPU上执行
    - 并行: 是指任意时刻点上,有多个程序同时运行在多个CPU上
    - 同步: 是指代码调用IO操作时,必须等待IO操作完成才返回调用方式
    - 异步: 是指代码调用IO操作时,不必等待IO操作完成就返回的调用方式
    - 阻塞: 是指调用函数时候当前线程被挂起
    - 非阻塞: 是指调用函数时候当前线程不会被挂起,而是立即返回

2. C10K问题和IO多路复用(select pool epoll)
    - select: select 函数监视的文件描述符分3类,分别writefds、readfds、exceptfds。
    调用后select函数会阻塞,直到有描述符就绪(有数据可读、可写、或者except),
     或者超时(timeout指定等待时间,如果立即返回null即可),函数返回,当select函数返回后
     可以通过遍历fdset,来找到就绪描述符
     select 目前几乎所有平台上支持,其良好跨平台支持也是它的一个优点,select的一个缺点
     在于单进程能够监视的文件描述符的数量存在最大限制,在Linux上一般1024,可以通过修改宏定义
     甚至重新编译内核的方式提升这一限制,但这样也会造成效率低下
    - pool: 不同于select使用三个位图来表示三个fdset的方式，pool使用一个
            pollfd的指针实现。
            pollfd结构包含了要监视的event和发生的event，不再使用select'参数-值'
            传递的方式。同时，pollfd并没有最大数量限制(但是数量过大后性能也是会下降的)
            和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符
            从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket
            。事实上，同时连接的大量客户端在一时刻可能只有很少处于就绪状态，因此随着
            监视的描述符数量的增长，其效率也会线性下降
    - epoll: epoll实在2.6内核中提出来的,是之前的select和poll的增强版。相对
             于select和poll来说，epoll更加灵活，没有描述符限制，epoll使用一个
             文件描述符管理多个描述符,将用户关系的文件描述符的事件存放到内核的一个
             事件表中, 这样在用户空间和内核空间的copy只需一次
3. epoll + 回调 + 时间循环方式url
4. 回调之痛
5. C10M问题和协程
    1. 回调模式编码复杂度高
    2. 同步编程的并发性不高
    3. 多线程编程需要线程间同步, lock 切换问题

    解决:

    1. 采用同步的方式去编写异步代码
    2. 使用单线程去切换任务
        1. 线程是由操作系统切换的, 单线程切换意味着需要程序猿自己调度任务
        2. 不在需要锁, 并发性高, 如果单线程内切换函数,性能远高于线程切换
        
6. 生成器的send和 yield from
7. 生成器如何变成协程
8. async和await原生协程
